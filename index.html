

<!-- 
参考
https://www.codegrid.net/articles/2020-webxr-3/

./WebXR Device APIを使う2.docx

ソースコード
https://github.com/codegrid/2020-webxr/blob/master/04_xr-hit-test.html


 -->

 




 <!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>平面検出</title>
<style>
body {margin: 0;}
canvas{display: block;}
#startButton{font-size: 50px;}
</style>
</head>
<body>

<!-- WebXR を起動するためには、ユーザーが意図して起動するための「ボタン」が必須。-->
<button type="button" id="startButton">ARカメラ起動</button>
<!-- WebXR の描画結果は WebGL の canvas となる。-->
<canvas id="xrCanvas"></canvas>

<script type="module">
// import * as THREE from 'https://unpkg.com/three@0.113.2/build/three.module.js';

import { ACESFilmicToneMapping, AddEquation, AddOperation, AdditiveBlending, AlphaFormat, AlwaysDepth, AlwaysStencilFunc, AmbientLight, AmbientLightProbe, AnimationClip, AnimationLoader, AnimationMixer, AnimationObjectGroup, AnimationUtils, ArcCurve, ArrayCamera, ArrowHelper, Audio, AudioAnalyser, AudioContext, AudioListener, AudioLoader, AxesHelper, AxisHelper, BackSide, BasicDepthPacking, BasicShadowMap, BinaryTextureLoader, Bone, BooleanKeyframeTrack, BoundingBoxHelper, Box2, Box3, Box3Helper, BoxBufferGeometry, BoxGeometry, BoxHelper, BufferAttribute, BufferGeometry, BufferGeometryLoader, ByteType, Cache, Camera, CameraHelper, CanvasRenderer, CanvasTexture, CatmullRomCurve3, CineonToneMapping, CircleBufferGeometry, CircleGeometry, ClampToEdgeWrapping, Clock, ClosedSplineCurve3, Color, ColorKeyframeTrack, CompressedTexture, CompressedTextureLoader, ConeBufferGeometry, ConeGeometry, CubeCamera, BoxGeometry as CubeGeometry, CubeReflectionMapping, CubeRefractionMapping, CubeTexture, CubeTextureLoader, CubeUVReflectionMapping, CubeUVRefractionMapping, CubicBezierCurve, CubicBezierCurve3, CubicInterpolant, CullFaceBack, CullFaceFront, CullFaceFrontBack, CullFaceNone, Curve, CurvePath, CustomBlending, CylinderBufferGeometry, CylinderGeometry, Cylindrical, DataTexture, DataTexture2DArray, DataTexture3D, DataTextureLoader, DecrementStencilOp, DecrementWrapStencilOp, DefaultLoadingManager, DepthFormat, DepthStencilFormat, DepthTexture, DirectionalLight, DirectionalLightHelper, DirectionalLightShadow, DiscreteInterpolant, DodecahedronBufferGeometry, DodecahedronGeometry, DoubleSide, DstAlphaFactor, DstColorFactor, DynamicBufferAttribute, DynamicCopyUsage, DynamicDrawUsage, DynamicReadUsage, EdgesGeometry, EdgesHelper, EllipseCurve, EqualDepth, EqualStencilFunc, EquirectangularReflectionMapping, EquirectangularRefractionMapping, Euler, EventDispatcher, ExtrudeBufferGeometry, ExtrudeGeometry, Face3, Face4, FaceColors, FileLoader, FlatShading, Float32Attribute, Float32BufferAttribute, Float64Attribute, Float64BufferAttribute, FloatType, Fog, FogExp2, Font, FontLoader, FrontFaceDirectionCCW, FrontFaceDirectionCW, FrontSide, Frustum, GammaEncoding, Geometry, GeometryUtils, GreaterDepth, GreaterEqualDepth, GreaterEqualStencilFunc, GreaterStencilFunc, GridHelper, Group, HalfFloatType, HemisphereLight, HemisphereLightHelper, HemisphereLightProbe, IcosahedronBufferGeometry, IcosahedronGeometry, ImageBitmapLoader, ImageLoader, ImageUtils, ImmediateRenderObject, IncrementStencilOp, IncrementWrapStencilOp, InstancedBufferAttribute, InstancedBufferGeometry, InstancedInterleavedBuffer, InstancedMesh, Int16Attribute, Int16BufferAttribute, Int32Attribute, Int32BufferAttribute, Int8Attribute, Int8BufferAttribute, IntType, InterleavedBuffer, InterleavedBufferAttribute, Interpolant, InterpolateDiscrete, InterpolateLinear, InterpolateSmooth, InvertStencilOp, JSONLoader, KeepStencilOp, KeyframeTrack, LOD, LatheBufferGeometry, LatheGeometry, Layers, LensFlare, LessDepth, LessEqualDepth, LessEqualStencilFunc, LessStencilFunc, Light, LightProbe, LightShadow, Line, Line3, LineBasicMaterial, LineCurve, LineCurve3, LineDashedMaterial, LineLoop, LinePieces, LineSegments, LineStrip, LinearEncoding, LinearFilter, LinearInterpolant, LinearMipMapLinearFilter, LinearMipMapNearestFilter, LinearMipmapLinearFilter, LinearMipmapNearestFilter, LinearToneMapping, Loader, LoaderUtils, LoadingManager, LogLuvEncoding, LoopOnce, LoopPingPong, LoopRepeat, LuminanceAlphaFormat, LuminanceFormat, MOUSE, Material, MaterialLoader, MathUtils as Math, MathUtils, Matrix3, Matrix4, MaxEquation, Mesh, MeshBasicMaterial, MeshDepthMaterial, MeshDistanceMaterial, MeshFaceMaterial, MeshLambertMaterial, MeshMatcapMaterial, MeshNormalMaterial, MeshPhongMaterial, MeshPhysicalMaterial, MeshStandardMaterial, MeshToonMaterial, MinEquation, MirroredRepeatWrapping, MixOperation, MultiMaterial, MultiplyBlending, MultiplyOperation, NearestFilter, NearestMipMapLinearFilter, NearestMipMapNearestFilter, NearestMipmapLinearFilter, NearestMipmapNearestFilter, NeverDepth, NeverStencilFunc, NoBlending, NoColors, NoToneMapping, NormalBlending, NotEqualDepth, NotEqualStencilFunc, NumberKeyframeTrack, Object3D, ObjectLoader, ObjectSpaceNormalMap, OctahedronBufferGeometry, OctahedronGeometry, OneFactor, OneMinusDstAlphaFactor, OneMinusDstColorFactor, OneMinusSrcAlphaFactor, OneMinusSrcColorFactor, OrthographicCamera, PCFShadowMap, PCFSoftShadowMap, PMREMGenerator, ParametricBufferGeometry, ParametricGeometry, Particle, ParticleBasicMaterial, ParticleSystem, ParticleSystemMaterial, Path, PerspectiveCamera, Plane, PlaneBufferGeometry, PlaneGeometry, PlaneHelper, PointCloud, PointCloudMaterial, PointLight, PointLightHelper, Points, PointsMaterial, PolarGridHelper, PolyhedronBufferGeometry, PolyhedronGeometry, PositionalAudio, PropertyBinding, PropertyMixer, QuadraticBezierCurve, QuadraticBezierCurve3, Quaternion, QuaternionKeyframeTrack, QuaternionLinearInterpolant, REVISION, RGBADepthPacking, RGBAFormat, RGBAIntegerFormat, RGBA_ASTC_10x10_Format, RGBA_ASTC_10x5_Format, RGBA_ASTC_10x6_Format, RGBA_ASTC_10x8_Format, RGBA_ASTC_12x10_Format, RGBA_ASTC_12x12_Format, RGBA_ASTC_4x4_Format, RGBA_ASTC_5x4_Format, RGBA_ASTC_5x5_Format, RGBA_ASTC_6x5_Format, RGBA_ASTC_6x6_Format, RGBA_ASTC_8x5_Format, RGBA_ASTC_8x6_Format, RGBA_ASTC_8x8_Format, RGBA_PVRTC_2BPPV1_Format, RGBA_PVRTC_4BPPV1_Format, RGBA_S3TC_DXT1_Format, RGBA_S3TC_DXT3_Format, RGBA_S3TC_DXT5_Format, RGBDEncoding, RGBEEncoding, RGBEFormat, RGBFormat, RGBIntegerFormat, RGBM16Encoding, RGBM7Encoding, RGB_ETC1_Format, RGB_PVRTC_2BPPV1_Format, RGB_PVRTC_4BPPV1_Format, RGB_S3TC_DXT1_Format, RGFormat, RGIntegerFormat, RawShaderMaterial, Ray, Raycaster, RectAreaLight, RedFormat, RedIntegerFormat, ReinhardToneMapping, RepeatWrapping, ReplaceStencilOp, ReverseSubtractEquation, RingBufferGeometry, RingGeometry, Scene, SceneUtils, ShaderChunk, ShaderLib, ShaderMaterial, ShadowMaterial, Shape, ShapeBufferGeometry, ShapeGeometry, ShapePath, ShapeUtils, ShortType, Skeleton, SkeletonHelper, SkinnedMesh, SmoothShading, Sphere, SphereBufferGeometry, SphereGeometry, Spherical, SphericalHarmonics3, SphericalReflectionMapping, Spline, SplineCurve, SplineCurve3, SpotLight, SpotLightHelper, SpotLightShadow, Sprite, SpriteMaterial, SrcAlphaFactor, SrcAlphaSaturateFactor, SrcColorFactor, StaticCopyUsage, StaticDrawUsage, StaticReadUsage, StereoCamera, StreamCopyUsage, StreamDrawUsage, StreamReadUsage, StringKeyframeTrack, SubtractEquation, SubtractiveBlending, TOUCH, TangentSpaceNormalMap, TetrahedronBufferGeometry, TetrahedronGeometry, TextBufferGeometry, TextGeometry, Texture, TextureLoader, TorusBufferGeometry, TorusGeometry, TorusKnotBufferGeometry, TorusKnotGeometry, Triangle, TriangleFanDrawMode, TriangleStripDrawMode, TrianglesDrawMode, TubeBufferGeometry, TubeGeometry, UVMapping, Uint16Attribute, Uint16BufferAttribute, Uint32Attribute, Uint32BufferAttribute, Uint8Attribute, Uint8BufferAttribute, Uint8ClampedAttribute, Uint8ClampedBufferAttribute, Uncharted2ToneMapping, Uniform, UniformsLib, UniformsUtils, UnsignedByteType, UnsignedInt248Type, UnsignedIntType, UnsignedShort4444Type, UnsignedShort5551Type, UnsignedShort565Type, UnsignedShortType, VSMShadowMap, Vector2, Vector3, Vector4, VectorKeyframeTrack, Vertex, VertexColors, VideoTexture, WebGLCubeRenderTarget, WebGLMultisampleRenderTarget, WebGLRenderTarget, WebGLRenderTargetCube, WebGLRenderer, WebGLUtils, WireframeGeometry, WireframeHelper, WrapAroundEnding, XHRLoader, ZeroCurvatureEnding, ZeroFactor, ZeroSlopeEnding, ZeroStencilOp, sRGBEncoding } from 'https://unpkg.com/three@0.113.2/build/three.module.js';



const width  = window.innerWidth;
const height = window.innerHeight;
const $button = document.getElementById( 'startButton' );

( async () => {

  // 任意のモードが利用可能かを調べる
  const isArSupported = navigator.xr && await navigator.xr.isSessionSupported( 'immersive-ar' );

  // モードが利用できなければ起動ボタンを無効化
  $button.disabled = ! isArSupported;

  // ユーザーが操作して初めて WebXR を起動できる
  $button.addEventListener( 'click', onEnterAR );

  async function onEnterAR() {

    $button.style.display = 'none';

    // immersive-ar を渡したときは、カメラからの現実の風景を入力することができる。
    // 他にも inline や vr のモードがある
    const xrSession = await navigator.xr.requestSession(
      'immersive-ar',
      { requiredFeatures: [ 'local', 'hit-test' ] }
    );

    // 本来は `getContext( 'webgl' )` で gl コンテキストを引き出す際に
    // オプションとして「`xrCompatible: true`」を明示する必要がある。
    // three.js では常に「`xrCompatible: true`」のオプションがついているので
    // ここでは特別な設定をせずに XR として利用することができる
    const renderer = new THREE.WebGLRenderer( { canvas: xrCanvas } );
    renderer.autoClear = false;
    renderer.setSize( width, height );

    const gl = renderer.getContext();

    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera();
    camera.matrixAutoUpdate = false;

    scene.add( new THREE.GridHelper( 100, 100 ) );

    const box = new THREE.Mesh(
      new THREE.BoxBufferGeometry( .2, .2, .2 ),
      new THREE.MeshNormalMaterial(),
    );
    scene.add( box );

    const cone = new THREE.Mesh(
      new THREE.ConeGeometry( 0.1, 0.5, 32, 32 ),
      new THREE.MeshNormalMaterial(),
    );
    scene.add( cone );

    // 「デバイスのカメラから取り込まれた現実の風景」の受け先となる、baseLayer を作る。
    const xrWebGLLayer = new XRWebGLLayer( xrSession, gl );
    // updateRenderState を設定していない場合、`xrSession.requestAnimationFrame` が呼ばれないので注意
    xrSession.updateRenderState( { baseLayer: xrWebGLLayer } );

    // 「デバイスの姿勢（pose）」の参照先を作る
    // これにより、デバイスの傾きや位置を取得できるようになる。
    const referenceSpace = await xrSession.requestReferenceSpace(
      'local',
      { requiredFeatures: ['local', 'hit-test'] }
    );

    // ヒットテスト用の Ray を作成する。
    // 以下の `hitTestInputReferenceSpace` は Ray の開始位置となる。
    // 特にオフセットを指定していないので、視点の中心が Ray の始点となるが、
    // 必要に応じてずらすことも可能。
    const hitTestInputReferenceSpace = await xrSession.requestReferenceSpace( 'viewer' );
    const hitTestSource = await xrSession.requestHitTestSource( { space: hitTestInputReferenceSpace } );

    // `window.requestAnimationFrame` ではなく、
    // セッションの `requestAnimationFrame` に応じて描画する。
    // 理由は以下の通り。
    //
    // - `window.requestAnimationFrame` の FPS はブラウザーの内部実装で最大 60 に抑えられているが、
    //   `xrSession.requestAnimationFrame` はデバイスの画面リフレッシュレートにに応じる
    // - `xrSession.requestAnimationFrame` では、第2引数として `xrFrame` を受け取ることができる。
    //   `xrFrame` は `window.requestAnimationFrame` には存在しない。
    xrSession.requestAnimationFrame( onDrawFrame );

    function onDrawFrame( timestamp, xrFrame ) {

      xrSession.requestAnimationFrame( onDrawFrame );
      // 姿勢を取り出す。行列（matrix）の要素が格納された配列で受け取ることができる。
      const pose = xrFrame.getViewerPose( referenceSpace );

      // xrFrame からは、現在のセッション、とベースレイヤーを取り出すこともできる。
      // xrFrame.session === xrSession;
      // xrSession.renderState.baseLayer === xrWebGLLayer;

      // ヒットテストを実行する。
      if ( hitTestSource && pose ) {

        const hitTestResults = xrFrame.getHitTestResults( hitTestSource );

        // なにかにヒットしていたら、最初にヒットした平面の座標を取得する。
        // 座標は pose として取得でき、その中に位置や角度が格納されている。
        if ( hitTestResults.length > 0 ) {

          const pose = hitTestResults[ 0 ].getPose( referenceSpace );

          cone.position.set(
            pose.transform.position.x,
            pose.transform.position.y,
            pose.transform.position.z
          );
          cone.quaternion.set(
            pose.transform.orientation.x,
            pose.transform.orientation.y,
            pose.transform.orientation.z,
            pose.transform.orientation.w,
          );

        }

      }

      // 現実の風景をWebGLのフレームバッファーに転写する
      gl.bindFramebuffer( gl.FRAMEBUFFER, xrWebGLLayer.framebuffer );

      if ( ! pose ) return;

      // if the xrSession is for both right and left eyes, length of views would be 2.
      // if not, length is 1,
      pose.views.forEach( ( view ) => {

        const viewport = xrWebGLLayer.getViewport( view );
        renderer.setSize( viewport.width, viewport.height );

        camera.matrix.fromArray( view.transform.matrix );
        camera.projectionMatrix.fromArray( view.projectionMatrix );
        camera.updateMatrixWorld( true );

        renderer.clearDepth();
        renderer.render( scene, camera );

      } );

    }

  }

} )();
</script>

</body>
</html>